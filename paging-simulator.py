# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wKdWRIhMhXnL9sr4miEaLieEeI811p42
"""

import os
import sys
from collections import deque, OrderedDict
import time

class PagingSimulator:
    def __init__(self, page_size=1024, num_pages=16, num_frames=8):
        """
        ====================
        INITIALIZATION - SETUP ALL COMPONENTS
        ====================
        This function initializes all data structures needed for the simulation
        """
        # PART A: Memory parameters from user input
        self.page_size = page_size          # Size of each page/frame in bytes
        self.num_pages = num_pages          # Total virtual pages in system
        self.num_frames = num_frames        # Total physical frames in RAM
        self.frame_size = page_size         # Usually frame size = page size

        # PART B: Initialize Page Table structure
        # Each entry has: valid bit, frame number, and optional bonus bits
        self.page_table = {}
        for i in range(num_pages):
            self.page_table[i] = {
                'valid': 0,      # 0 = page not in memory, 1 = page in memory
                'frame': -1,     # Which frame contains this page (-1 if not in memory)
                'present': 0,    # BONUS: Present in memory (similar to valid)
                'modified': 0,   # BONUS: Dirty bit - page has been written to
                'referenced': 0  # BONUS: Accessed bit - page has been referenced
            }

        # PART C: Frame allocation table for visualization
        # Maps frame numbers to page numbers (-1 means frame is free)
        self.frame_allocation = {}
        for i in range(num_frames):
            self.frame_allocation[i] = -1  # -1 means free frame

        # PART D: Data structures for page replacement algorithms
        self.free_frames = list(range(num_frames))  # List of available frames
        self.page_faults = 0                        # Counter for page faults

        # PART D: Replacement algorithm selection and data structures
        self.replacement_policy = "FIFO"  # Default policy
        self.access_history = deque()     # For FIFO algorithm (queue of pages)
        self.page_access_time = {}        # For LRU algorithm (page -> last access time)

        # Statistics tracking for performance analysis
        self.stats = {
            'total_accesses': 0,  # Total memory accesses attempted
            'page_faults': 0,     # How many page faults occurred
            'hits': 0             # How many times page was found in memory
        }

    def set_replacement_policy(self, policy):
        """
        PART D: Set the page replacement algorithm
        Allows user to choose between FIFO, LRU, and RANDOM
        """
        valid_policies = ["FIFO", "LRU", "RANDOM"]
        if policy.upper() in valid_policies:
            self.replacement_policy = policy.upper()
            print(f"Replacement policy set to: {self.replacement_policy}")
        else:
            print(f"Invalid policy. Using default: {self.replacement_policy}")

    def translate_address(self, logical_address):
        """
        ====================
        PART A: LOGICAL TO PHYSICAL ADDRESS TRANSLATION
        ====================
        This is the CORE function that implements address translation
        Follows the formulas specified in Part A of the assignment:
        1. Page Number = Logical Address // Page Size
        2. Offset = Logical Address % Page Size
        3. Physical Address = Frame Number Ã— Frame Size + Offset

Returns: (page_num, offset, frame_num, physical_addr, page_fault)
        """
        # Step 1: Calculate Page Number (as per assignment formula)
        page_num = logical_address // self.page_size

        # Step 2: Calculate Offset (as per assignment formula)
        offset = logical_address % self.page_size

        # Validate page number (check if within allowed range)
        if page_num >= self.num_pages:
            return None, None, None, None, False

        # Update statistics
        self.stats['total_accesses'] += 1

        # Check if page is in memory (valid bit = 1)
        if self.page_table[page_num]['valid'] == 1:
            # ====================
            # PAGE HIT - Page is in memory
            # ====================
            frame_num = self.page_table[page_num]['frame']

            # Step 3: Calculate Physical Address (as per assignment formula)
            physical_addr = (frame_num * self.frame_size) + offset

            # PART D: Update LRU access time if using LRU algorithm
            if self.replacement_policy == "LRU":
                self.page_access_time[page_num] = time.time()

            # Update hit statistics
            self.stats['hits'] += 1

            # Return successful translation
            return page_num, offset, frame_num, physical_addr, False

        else:
            # ====================
            # PAGE FAULT - Page is not in memory
            # ====================
            self.stats['page_faults'] += 1
            self.page_faults += 1

            # PART D: Handle the page fault
            frame_num = self.handle_page_fault(page_num)

            if frame_num is not None:
                # After loading page, calculate physical address
                physical_addr = (frame_num * self.frame_size) + offset
                return page_num, offset, frame_num, physical_addr, True
            else:
                # Failed to handle page fault
                return page_num, offset, None, None, True

    def handle_page_fault(self, page_num):
        """
        ====================
        PART D: PAGE FAULT HANDLING
        ====================
        Implements the complete page fault handling process:
        1. Display "Page Fault Occurred" message
        2. Find free frame or replace a page
        3. Load page into memory
        4. Update page table

        Follows exactly the requirements from Part D of assignment
        """
        print(f"\n PAGE FAULT OCCURRED for Page {page_num}")

        # Step 1: Check for free frames first
        if self.free_frames:
            # There is a free frame available
            frame_num = self.free_frames.pop(0)  # Take first free frame
            self.load_page(page_num, frame_num)  # Load page into frame
            return frame_num
        else:
            # ====================
            # NO FREE FRAMES - Need to replace a page
            # ====================
            print("No free frames available. Page replacement required.")

            # PART D: Select victim page based on replacement policy
            if self.replacement_policy == "FIFO":
                victim_page = self.fifo_replace()
            elif self.replacement_policy == "LRU":
                victim_page = self.lru_replace()
            elif self.replacement_policy == "RANDOM":
                victim_page = self.random_replace()
            else:
                victim_page = self.fifo_replace()  # Default fallback

            if victim_page is not None:
                # Get the frame currently occupied by victim page
                frame_num = self.page_table[victim_page]['frame']

                # PART D: If victim page was modified, write to disk (BONUS feature)
                if self.page_table[victim_page]['modified'] == 1:
                    print(f"Writing modified Page {victim_page} to disk...")

                # Remove victim page from memory
                self.page_table[victim_page]['valid'] = 0
                self.page_table[victim_page]['frame'] = -1
                self.page_table[victim_page]['present'] = 0

                # Load new page into the freed frame
                self.load_page(page_num, frame_num)
                return frame_num

        return None  # Could not handle page fault

    def fifo_replace(self):
        """
        PART D: FIFO (First-In, First-Out) Replacement Algorithm
        Replaces the oldest page in memory
        """
        if self.access_history:
            victim_page = self.access_history.popleft()  # Remove oldest page
            print(f"FIFO: Replacing Page {victim_page}")
            return victim_page
        return None

    def lru_replace(self):
        """
        PART D: LRU (Least Recently Used) Replacement Algorithm
        Replaces the page that hasn't been used for the longest time
        """
        if self.page_access_time:
            # Find page with oldest (minimum) access time
            victim_page = min(self.page_access_time.items(), key=lambda x: x[1])[0]
            print(f"LRU: Replacing Page {victim_page} (oldest access)")
            del self.page_access_time[victim_page]  # Remove from tracking
            return victim_page
        return None

    def random_replace(self):
        """
        PART D: RANDOM Replacement Algorithm
        Replaces a randomly selected page
        """
        # Find all pages currently in memory
        pages_in_memory = [p for p, info in self.page_table.items()
                          if info['valid'] == 1]

        if pages_in_memory:
            import random
            victim_page = random.choice(pages_in_memory)  # Random selection
            print(f"RANDOM: Replacing Page {victim_page}")
            return victim_page
        return None

    def load_page(self, page_num, frame_num):
        """
        PART D: Load a page into memory
        Updates all necessary data structures after page is loaded
        """
        print(f" Loading Page {page_num} into Frame {frame_num}")

        # PART B: Update page table entry
        self.page_table[page_num]['valid'] = 1
        self.page_table[page_num]['frame'] = frame_num
        self.page_table[page_num]['present'] = 1
        self.page_table[page_num]['referenced'] = 1  # BONUS: Reference bit

        # PART C: Update frame allocation table
        self.frame_allocation[frame_num] = page_num

        # PART D: Update replacement algorithm data structures
        self.access_history.append(page_num)  # For FIFO
        self.page_access_time[page_num] = time.time()  # For LRU

    def display_page_table(self):
        """
        ====================
        PART B & C: PAGE TABLE DISPLAY
        ====================
        Shows the page table with all required information:
        - Page Number (required)
        - Valid/Invalid bit (required)
        - Frame Number (required)
        - Bonus bits: Present, Modified, Referenced (optional bonus)

        This satisfies both Part B (page table simulation) and
        Part C (visual representation - table printed in console)
        """
        print("\n" + "="*70)
        print("PAGE TABLE")
        print("="*70)
        # Table headers
        print(f"{'Page':<6} {'Valid':<8} {'Frame':<8} {'Present':<10} {'Modified':<10} {'Referenced':<12}")
        print("-"*70)

        # Display each page table entry
        for page_num, info in self.page_table.items():
            valid_str = "Yes" if info['valid'] == 1 else "No"
            frame_str = str(info['frame']) if info['frame'] != -1 else "-"
            present_str = "Yes" if info['present'] == 1 else "No"
            modified_str = "Yes" if info['modified'] == 1 else "No"
            referenced_str = "Yes" if info['referenced'] == 1 else "No"

            # Print formatted row
            print(f"{page_num:<6} {valid_str:<8} {frame_str:<8} {present_str:<10} {modified_str:<10} {referenced_str:<12}")

    def display_memory_map(self):
        """
        ====================
        PART C: VISUAL REPRESENTATION
        ====================
        Shows memory mapping visualization - ASCII diagram showing
        pages mapped to frames with clear indication of invalid pages
        This satisfies Part C requirement for visual representation
        """
        print("\n" + "="*70)
        print("MEMORY MAPPING (Pages â†’ Frames)")
        print("="*70)
        print(f"{'Frame':<8} {'Page':<8} {'Status':<15}")
        print("-"*70)

        # Display each frame's status
        for frame_num, page_num in self.frame_allocation.items():
            if page_num == -1:
                # Free frame
                status = "FREE"
                page_str = "-"
            else:
                # Occupied frame - check if page is valid
                page_str = str(page_num)
                if self.page_table[page_num]['valid'] == 1:
                    status = "LOADED"
                else:
                    status = "INVALID"  # Shouldn't happen, but safety check

            print(f"{frame_num:<8} {page_str:<8} {status:<15}")

    def display_statistics(self):
        """
        PART C: Statistics display for analysis
        Shows performance metrics of the simulation
        """
        print("\n" + "="*70)
        print("SIMULATION STATISTICS")
        print("="*70)
        print(f"Total Memory Accesses: {self.stats['total_accesses']}")
        print(f"Page Faults: {self.stats['page_faults']}")
        print(f"Hits: {self.stats['hits']}")

        # Calculate rates if we have accesses
        if self.stats['total_accesses'] > 0:
            fault_rate = (self.stats['page_faults'] / self.stats['total_accesses']) * 100
            hit_rate = (self.stats['hits'] / self.stats['total_accesses']) * 100
            print(f"Page Fault Rate: {fault_rate:.2f}%")
            print(f"Hit Rate: {hit_rate:.2f}%")

        print(f"Replacement Policy: {self.replacement_policy}")

    def mark_page_modified(self, page_num):
        """
        BONUS FEATURE: Mark a page as modified (dirty bit)
        Used to simulate write operations
        """
        if page_num in self.page_table:
            self.page_table[page_num]['modified'] = 1

    def simulate_accesses(self, addresses, mark_modified=None):
        """
        ====================
        COMPLETE SIMULATION RUN
        ====================
        Runs a complete simulation with multiple address accesses
        Demonstrates all parts working together
        """
        print("\n" + "="*70)
        print("ADDRESS TRANSLATION SIMULATION")
        print("="*70)

        # Optional: Mark some pages as modified (for bonus feature)
        if mark_modified:
            for page in mark_modified:
                self.mark_page_modified(page)

        # Process each address
        for i, addr in enumerate(addresses):
            print(f"\n--- Access {i+1}: Logical Address = {addr} ---")

            # PART A: Translate address (may trigger PART D page faults)
            page_num, offset, frame_num, phys_addr, page_fault = self.translate_address(addr)

            if page_num is not None:
                print(f"ðŸ“„ Page: {page_num}, Offset: {offset}")
                if page_fault:
                    if frame_num is not None:
                        print(f" Page fault handled. Page {page_num} loaded into Frame {frame_num}.")
                        print(f" Frame: {frame_num}")
                        print(f" Physical Address: {phys_addr}")
                    else:
                        print(f" Page fault occurred but could not be handled.")
                else:
                    print(f" Page Hit!")
                    print(f" Frame: {frame_num}")
                    print(f" Physical Address: {phys_addr}")
            else:
                print(f" Error: Logical Address {addr} maps to an invalid page number.")

            # PART B & C: Show current state after each access
            self.display_page_table()    # Show page table
            self.display_memory_map()    # Show memory map

            # Pause between accesses for demonstration
            if i < len(addresses) - 1:
                input("\nPress Enter for next access...")

def main():
    """
    ====================
    MAIN PROGRAM - USER INTERFACE
    ====================
    Provides interactive interface for the simulation
    Gets ALL parameters from user as required
    """
    print("="*70)
    print("PAGING SIMULATION PROJECT - MEMORY MANAGEMENT")

    # ====================
    # PART A: GET PAGING PARAMETERS FROM USER
    # ====================
    print("\nðŸ“‹ Simulation Parameters:")

    # Get page size (with default value)
    page_size = int(input("Enter page size (bytes, default 1024): ") or 1024)

    # Get number of pages (virtual memory size)
    num_pages = int(input("Enter number of pages (default 16): ") or 16)

    # Get number of frames (physical memory size)
    num_frames = int(input("Enter number of frames (default 8): ") or 8)

    # Create simulator instance with user parameters
    simulator = PagingSimulator(page_size, num_pages, num_frames)

    # ====================
    # PART D: SELECT REPLACEMENT ALGORITHM
    # ====================
    print("\n Page Replacement Policies:")
    print("1. FIFO (First-In, First-Out)")
    print("2. LRU (Least Recently Used)")
    print("3. RANDOM")

    # Get user choice for replacement algorithm
    choice = input("Choose policy (1-3, default 1): ") or "1"

    # Map choice to policy name
    policies = {"1": "FIFO", "2": "LRU", "3": "RANDOM"}
    simulator.set_replacement_policy(policies.get(choice, "FIFO"))

    # ====================
    # INITIAL MEMORY STATE
    # ====================
    # Pre-load some pages to show initial memory state
    print("\n Pre-loading some pages into memory...")
    for i in range(3):
        if simulator.free_frames:
            simulator.load_page(i, simulator.free_frames.pop(0))

    # ====================
    # PART A: GET LOGICAL ADDRESSES FROM USER
    # ====================
    print("\n Enter logical addresses to translate (comma-separated):")
    addr_input = input("Example: 5000, 2048, 7000, 100: ") or "5000, 2048, 7000, 100"
    addresses = [int(addr.strip()) for addr in addr_input.split(",")]

    # ====================
    # BONUS: MARK PAGES AS MODIFIED
    # ====================
    modified_pages = input("\n Enter pages to mark as modified (comma-separated, optional): ")
    if modified_pages:
        modified = [int(p.strip()) for p in modified_pages.split(",")]
    else:
        modified = None

    # ====================
    # RUN COMPLETE SIMULATION
    # ====================
    # This runs Parts A, B, C, and D together
    simulator.simulate_accesses(addresses, modified)

    # ====================
    # SHOW FINAL STATISTICS
    # ====================
    simulator.display_statistics()

    # ====================
    # INTERACTIVE MODE FOR DEMONSTRATION
    # ====================
    print("\n" + "="*70)
    print("INTERACTIVE MODE")
    print("="*70)

    # Interactive loop for live demonstration
    while True:
        print("\nOptions:")
        print("1. Translate new address")
        print("2. View page table")
        print("3. View memory map")
        print("4. View statistics")
        print("5. Mark page as modified")
        print("6. Exit")

        choice = input("Enter choice (1-6): ")

        if choice == "1":
            # PART A: Translate a single address
            addr = int(input("Enter logical address: "))
            page_num, offset, frame_num, phys_addr, page_fault = simulator.translate_address(addr)
            print(f"\nTranslation Result:")
            if page_num is not None:
                print(f"  Page: {page_num}, Offset: {offset}")
                if page_fault:
                    if frame_num is not None:
                        print(f"   Page fault handled. Page {page_num} loaded into Frame {frame_num}.")
                        print(f"   Frame: {frame_num}")
                        print(f"   Physical Address: {phys_addr}")
                    else:
                        print(f"   Page fault occurred but could not be handled.")
                else:
                    print(f"   Page Hit!")
                    print(f"   Frame: {frame_num}")
                    print(f"   Physical Address: {phys_addr}")
            else:
                print(f"   Error: Logical Address {addr} maps to an invalid page number.")

        elif choice == "2":
            # PART B & C: Display page table
            simulator.display_page_table()

        elif choice == "3":
            # PART C: Display memory map
            simulator.display_memory_map()

        elif choice == "4":
            # Show statistics
            simulator.display_statistics()

        elif choice == "5":
            # BONUS: Mark page as modified
            page_num = int(input("Enter page number to mark as modified: "))
            simulator.mark_page_modified(page_num)
            print(f"Page {page_num} marked as modified")

        elif choice == "6":
            print("Exiting simulator. Goodbye!")
            break

        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()